require "./ast/*"
require "./lexer"
require "./token"

module Drizzle
  # A Parser reads in the tokens generated by a `Lexer` and constructs an Abstract Syntax Tree (AST) built from what it finds.
  class Parser
    @lexer : Lexer
    @current : Token
    @peek : Token
    @errors : Array(String) = [] of String

    def initialize(@lexer : Lexer)
      # Read the first two tokens to set up curr and peek variables
      @current = @lexer.get_next_token
      @peek = @lexer.get_next_token
    end

    # Update the `@current` and `@peek` pointers contained in the Parser instance to the next token generated from the `Lexer`
    def next_token
      @current = @peek
      @peek = @lexer.get_next_token
    end

    # Parse a program and build a program node from it, and return it
    def parse_program : AST::Program
      statements = [] of AST::Statement
      while !@current.token_type.eof?
        statement = self.parse_statement
        if !statement.nil?
          statements << statement
        end
        self.next_token
      end
      return AST::Program.new statements
    end

    # Parse a statement found at `@current` and return it, or nil if no statement can be parsed
    def parse_statement : AST::Statement?
      case @current.token_type
      when TokenType::LET
        return self.parse_let_statement
      when TokenType::RETURN
        return self.parse_return_statement
      end
      # We shouldn't reach this point but just in case
      return nil
    end

    # Parse a `Let` statement found at the current token, and return it, or nil if a valid let statement can not be made
    def parse_let_statement : AST::Let?
      # Ensure that the token setup is how we need it to be for a let statement: let <ident>: <ident> = <exp>
      token = @current

      if !self.eat? TokenType::IDENTIFIER
        return nil
      end

      # Generate an Identifier node for the name
      name = AST::Identifier.new @current, @current.literal

      # Expect a colon token next
      if !self.eat? TokenType::COLON
        return nil
      end
      # The COLON token is ignored when building a let statement node but it has to be there

      # Expect another identifier here
      if !self.eat? TokenType::IDENTIFIER
        return nil
      end

      # Generate an Identifier node for the type
      datatype = AST::Identifier.new @current, @current.literal

      # For now we will skip the expression part (skip to the next let token)
      while !@peek.token_type.let?
        if @current.token_type.eof?
          break
        end
        self.next_token
      end
      # TODO - Implement the parsing of expressions
      expression = nil

      return AST::Let.new token, name, datatype, expression
    end

    # Parse a `Return` statement found at the current token, and return it, or nil if a valid return statement can not be made
    def parse_return_statement : AST::Return?
      token = @current

      # Get the next token
      self.next_token

      # TODO - Parse expressions properly
      while !@peek.token_type.return?
        if @current.token_type.eof?
          break
        end
        self.next_token
      end
      expression = nil

      # Create and return the node
      return AST::Return.new token, expression
    end

    # "Eat" the `@peek` token if the expected type matches the type of `@peek`
    #
    # Eating a token involves passing in the type of token that `@peek` is expected to be.
    # If it is the expected type, this method will advance the parser to the next token
    def eat?(expected_type : TokenType) : Bool
      if @peek.token_type == expected_type
        self.next_token
        return true
      else
        self.eat_error expected_type
        return false
      end
    end

    # Error functions

    # Add an error when `#eat?` gets an incorrect token type
    def eat_error(expected_type : TokenType)
      @errors << "SyntaxError: Expected #{expected_type}, got #{@peek.token_type}\n\t#{@peek.file_name} at line #{@peek.line_num}, char #{@peek.char_num}"
    end

    # Getters and setters (writing them myself because I know the tokens will never be nil)

    # The token that is currently being inspected by the parser
    getter current

    # A pointer to the next token coming up in the stream.
    # This is used to help guide what kind of node will be built from `@current`
    getter peek

    # Maintain an array of errors that are generated during the parsing step
    getter errors
  end
end
