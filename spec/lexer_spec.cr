require "./spec_helper"

# Unlike how the interpreter book works, we're going to be using files from the start
# These files are going to be stored in `/spec/lexer_test_files/*.sph`
describe Sapphire::Lexer do
  it "correctly creates Token instances for all single character tokens in Sapphire" do
    # Lexer also handles strings. This is for REPL and such. This might change later.
    input = "=+(){},:"
    filename = "<stdin>"

    # Generate an array of tokens that are expected to be generated by the Lexer
    expected_tokens = [
      Sapphire::Token.new(Sapphire::TokenType::ASSIGN, "=", filename, 1, 1),
      Sapphire::Token.new(Sapphire::TokenType::PLUS, "+", filename, 1, 2),
      Sapphire::Token.new(Sapphire::TokenType::LEFT_PAREN, "(", filename, 1, 3),
      Sapphire::Token.new(Sapphire::TokenType::RIGHT_PAREN, ")", filename, 1, 4),
      Sapphire::Token.new(Sapphire::TokenType::LEFT_BRACE, "{", filename, 1, 5),
      Sapphire::Token.new(Sapphire::TokenType::RIGHT_BRACE, "}", filename, 1, 6),
      Sapphire::Token.new(Sapphire::TokenType::COMMA, ",", filename, 1, 7),
      Sapphire::Token.new(Sapphire::TokenType::COLON, ":", filename, 1, 8),
      Sapphire::Token.new(Sapphire::TokenType::EOF, "\0", filename, 1, 9),
    ]

    # Create a lexer for this file
    lexer = Sapphire::Lexer.new input

    # Loop through the expected_tokens array and ensure that the tokens match the lexer output
    expected_tokens.each do |expected|
      received = lexer.get_next_token
      received.token_type.should eq expected.token_type
      received.literal.should eq expected.literal
      received.file_name.should eq expected.file_name
      received.line_num.should eq expected.line_num
      received.char_num.should eq expected.char_num
    end
  end
end
